







# 计算机网络

## 网络模型

### OSI七层模型 和TCP/IP五层模型

![img](面经.assets/705728-20160424234825491-384470376.png)

### 

![img](面经.assets/9d9b3c9274465c94e223676b6d434194.png)

### 二层转发、三层路由

> 二层转发对应OSI模型的数据链路层，就是解决数据本地传输的问题，具体，利用交换机等2层设备mac地址学习和端口的映射，实现数据的本地转发 三层路由对应OSI模型的网络层，解决网际间数据传输的问题，具体通过路由选路，将数据发往指定IP所在的网络。
>
> 



## 五种IO模型

> - 阻塞和非阻塞：在read的时候，是等待内核数据就绪还是直接返回，如果直接返回则为非阻塞，等待数据准备则为阻塞
> - 同步和异步：如果请求放在发送请求到最后完成的这一段过程中都需要自己参与就是同步，请求完了之后返回就是异步。

### 阻塞IO

> ​	一直等待内核数据准备好了，然后返回

### 非阻塞IO

> ​	调用后内核中的数据没有就绪就返回一个错误码，然后轮询，直到有数据

### 多路复用IO

>  	非阻塞io中一个线程监听一个连接，在高并发场景下，需要创建大量的线程，消费系统资源。
>
> ​	 用一个线程去监听多个连接，也就是一个或者多个fd，当fd有数据的时候，select、poll、epool会返回需要进行下一步操作的fd，然后下一步操作交给对应的线程池去处理。

### 信号驱动IO

> ​	多路复用io中的select 通过轮询的方式来监控多个fd，通过轮询判断fd是否可读，轮询的方式比较暴力，比较消费资源。
>
> ​	在发起系统调用的时候向内核注册一个回调函数，数据准备好了之后，会通知应用直接去读取数据

### 异步IO

> 发起系统调用告知内核发起某个操作，当操作完成后告知应用，完成了轮询和拷贝两个动作。
>
> Windows 的 IOCP 和 Linux 内核 2.6 的 AIO 都提供了异步 I/O 的支持，Java 的 NIO.2 API 就是对操作系统异步 I/O API 的封装
>
> Java的NIO.2是通过epoll来模拟实现的

## 零拷贝

> ​	mmap 减少了内核态到用户态的拷贝
>
> ​	sendfile

## HTTP/HTTPS

### 输入url经历的所有过程

1. 浏览器对url进行安全检查，访问限制检查。
2. 浏览器查询缓存，如果存在缓存就直接返回
3. 通过DNS查询ip地址，判断浏览器缓存、操作系统缓存、路由器缓存、ISP缓存，都没有的话DNS服务器就把请求转发到互联网根域

![img](面经.assets/v2-57eb007db72ad239123d56448a2a1d01_b.jpg)

4. 浏览器通过URL封装HTTP请求头，请求体
5. 传输层
6. 网络层
7. 链路层
8. 物理层

![img](面经.assets/v2-6e7f3f12f414b1e970467f50c0062c6e_b.jpg)

### 三次握手

### 四次挥手

### HTTPS证书交换过程



# 操作系统

## 进程的通讯方式

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 进程的调度算法

为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 虚拟内存



# 微服务



# 常考算法

# JVM

# Mysql

# Redis

# RabbitMq

https://blog.csdn.net/o9109003234/article/details/115843165

# 源码分析

## Tomcat

> HTTP服务器+Servlet容器
>
> - 合理划分功能模块
> - 基于组件化设计
> - 合理的运用了设计模式，使代码结构清晰整洁，提高了扩展性

#### 执行流程

> ​	通过端口找到唯一的->service->Engine->通过域名确定Host->通过URL找到Context组件->Wrapper

![img](面经.assets/578edfe9c06856324084ee193243694d.png)

#### Servlet规范

> ​	

#### 整体架构

![img](面经.assets/12ad9ddc3ff73e0aacf2276bcfafae9b.png)

#### io多路复用模型

![img](面经.assets/c4bbda75005dd5e8519c2bc439359465.jpg)

#### 相关的设计模式

****

##### **抽象模板方法**

![img](面经.assets/13850ee56c3f09cbabe9892e84502155.jpg)

连接器中提供了HTTP/1.1 , HTTP/2, AJP 

IO模型有NIO,AIO,APR

##### 责任链模式

- 过滤器 FilterChain

- Pipeline的Valve

  > ​	整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：

  ```java
  // Calling the container
  connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
  ```

  

![img](面经.assets/b014ecce1f64b771bd58da62c05162ca.jpg)

```java

public interface Pipeline extends Contained {
  public void addValve(Valve valve);
  public Valve getBasic();
  public void setBasic(Valve valve);
  public Valve getFirst();
}
```

> 只要在Adapter中触发调用Engine中的第一个Valve,后面的所有Valve都会被调用。
>
> Wrapper中的最后一个Valve会创建一个Filter链，并调用doFilter方法，最终会调用Servlet的service方法。
>
> ```java	
> // Calling the container
> connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
> ```

##### 适配器模式

> Adapter一层使用的是适配器设计模式，好处是当容器版本升级只修改Adaper组件适配到新版本容器就可以了，protocal handler组件代码不需要改动
>
> 将 tomcatRequest ->ServletRequest ，将tomcatResponse -> ServletResponse

##### 组合模式

> 容器之间的关系是通过组合模式来管理的
>
> 所有的容器都实现了Container接口
>
> ```java
> public interface Container extends Lifecycle {
>     public void setName(String name);
>     public Container getParent();
>     public void setParent(Container container);
>     public void addChild(Container child);
>     public void removeChild(Container child);
>     public Container findChild(String name);
> }
> ```

##### 监听器模式

> 实现了一键启停	
>
> ContainerBase 调用 start方法的时候 会调用LifeCycleBase中的setState，再调用setStateInternal，再调用fireLifeCycleEvent

## Mybatis

## Spring

## JUC

## AQS

## collection



# 重构/代码优化技巧

# 工作中遇到的难点

