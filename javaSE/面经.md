







# 计算机网络

## 网络模型

### OSI七层模型

### TCP/IP五层模型



## 五种IO模型

### AIO

> Windows 的 IOCP 和 Linux 内核 2.6 的 AIO 都提供了异步 I/O 的支持，Java 的 NIO.2 API 就是对操作系统异步 I/O API 的封装
>
> Java的NIO.2是通过epoll来模拟实现的

## 内核态和用户态

## 零拷贝

## HTTP/HTTPS

### 输入url经历的所有过程

### 三次握手

### 四次挥手

### HTTPS证书交换过程



# 操作系统

## 线程和进程

### 进程如何通讯

### 线程如何通讯

## 虚拟内存



# 微服务



# 常考算法

# JVM

# Mysql

# Redis

# RabbitMq

# 源码分析

## Tomcat

> HTTP服务器+Servlet容器
>
> - 合理划分功能模块
> - 基于组件化设计
> - 合理的运用了设计模式，使代码结构清晰整洁，提高了扩展性

#### 执行流程

> ​	通过端口找到唯一的->service->Engine->通过域名确定Host->通过URL找到Context组件->Wrapper

![img](面经.assets/578edfe9c06856324084ee193243694d.png)

#### Servlet规范

> ​	

#### 整体架构

![img](面经.assets/12ad9ddc3ff73e0aacf2276bcfafae9b.png)

#### io多路复用模型

![img](面经.assets/c4bbda75005dd5e8519c2bc439359465.jpg)

#### 相关的设计模式

****

##### **抽象模板方法**

![img](面经.assets/13850ee56c3f09cbabe9892e84502155.jpg)

连接器中提供了HTTP/1.1 , HTTP/2, AJP 

IO模型有NIO,AIO,APR

##### 责任链模式

- 过滤器 FilterChain

- Pipeline的Valve

  > ​	整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：

  ```java
  // Calling the container
  connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
  ```

  

![img](面经.assets/b014ecce1f64b771bd58da62c05162ca.jpg)

```java

public interface Pipeline extends Contained {
  public void addValve(Valve valve);
  public Valve getBasic();
  public void setBasic(Valve valve);
  public Valve getFirst();
}
```

> 只要在Adapter中触发调用Engine中的第一个Valve,后面的所有Valve都会被调用。
>
> Wrapper中的最后一个Valve会创建一个Filter链，并调用doFilter方法，最终会调用Servlet的service方法。
>
> ```java	
> // Calling the container
> connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
> ```

##### 适配器模式

> Adapter一层使用的是适配器设计模式，好处是当容器版本升级只修改Adaper组件适配到新版本容器就可以了，protocal handler组件代码不需要改动
>
> 将 tomcatRequest ->ServletRequest ，将tomcatResponse -> ServletResponse

##### 组合模式

> 容器之间的关系是通过组合模式来管理的
>
> 所有的容器都实现了Container接口
>
> ```java
> public interface Container extends Lifecycle {
>     public void setName(String name);
>     public Container getParent();
>     public void setParent(Container container);
>     public void addChild(Container child);
>     public void removeChild(Container child);
>     public Container findChild(String name);
> }
> ```

##### 监听器模式

> 实现了一键启停	
>
> ContainerBase 调用 start方法的时候 会调用LifeCycleBase中的setState，再调用setStateInternal，再调用fireLifeCycleEvent

## Mybatis

## Spring

## JUC

## AQS

## collection



# 重构/代码优化技巧

# 工作中遇到的难点

