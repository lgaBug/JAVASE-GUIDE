# 并发编程学习

## 学习攻略

**"跳出来，看全景"，"钻进去，看本质"**

并发编程全景图

![image-20200112115256604](\JUC学习.assets\image-20200112115256604.png)

## 并发理论基础

### 并发编程Bug的源头

- 可见性(CPU 缓存导致的)
- 原子性（线程切换带来的，例如i++等复合操作，CPU中只能保证CPU指令的有需要，无法保证高级语言的有序性）
- 有序性（编译优化带来的）

### 可见性和有序性问题

按需禁用缓存和编译优化

#### **JAVA内存模型**

本质上理解：Java 内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括了**volatile**、**synchronized**和**final**三个关键字，以及六项Happens-Before规则。

#### **Happens-Before**

Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则

A happens-Before B,A的操作对于B来说是可见的，无论A和B是否在同一个线程中。

- 程序的顺序性规则
- volatile的变量规则（对一个用volatile变量修饰的写操作，Happens-Before与后续对该变量的读操作）
- 传递性规则
- 管程中的锁规则（指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。）
- 线程的start规则（主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作）
- 线程的join规则（线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回）

### 原子性问题

产生原子性问题：线程切换

解决方案：禁用线程切换，禁止CPU中断，操作系统就不会进行重新调度线程。该解决方案在单核CPU中行的通，但是在多核CPU下就行不通了。

最终解决方案：加锁。互斥锁。**同一时刻只有一个线程执行**

**解决原子性问题，是保证中间状态对外不可见**

不能用可变的对象做为锁

### 死锁问题

产生死锁的条件：

- 互斥，共享资源 X 和 Y 只能被一个线程占用；
- 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
- 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
- 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

反过来分析，也就是说只要我们**破坏其中一个，就可以成功避免死锁的发生。**